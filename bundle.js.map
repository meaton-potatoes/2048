{"version":3,"sources":["webpack:///webpack/bootstrap 5467dc0913d9823f36de","webpack:///./index.js","webpack:///./js/game.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA2B;AAC3B;AACA,MAAK,6BAA6B;AAClC;AACA,MAAK,6BAA6B;AAClC;AACA,MAAK,6BAA6B;AAClC;AACA;AACA,IAAG;AACH,EAAC;;;;;;;AClBD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAA+B,mBAAmB;AAClD;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,kBAAiB,uBAAuB;AACxC,oBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA6B,UAAU;AACvC;AACA,kBAAiB,uBAAuB;AACxC,oBAAmB,uBAAuB;AAC1C;AACA,mDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,uBAAuB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,uBAAuB;AAC1C,sBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,wCAAuC,QAAQ;AAC/C,0CAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE,UAAU,GAAG,gCAAgC;AAC7G,YAAW;AACX,iEAAgE,UAAU,GAAG,gCAAgC;AAC7G;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,uDAAsD,UAAU,GAAG,mCAAmC;AACtG,YAAW;AACX,uDAAsD,UAAU,GAAG,mCAAmC;AACtG;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,mDAAkD,UAAU,GAAG,mCAAmC;AAClG,QAAO;AACP,mDAAkD,UAAU,GAAG,mCAAmC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5467dc0913d9823f36de\n **/","const Game = require(\"./js/game\");\n\n$(document).ready(function(){\n  $(\"#gameover-modal\").hide();\n  let game = new Game();\n  game.render();\n\n  $(document).keydown(function(e){\n    if (e.keyCode === 38) { // up\n      game.moveTiles(\"up\");\n    } else if (e.keyCode === 40) { // down\n      game.moveTiles(\"down\");\n    } else if (e.keyCode === 37) { // left\n      game.moveTiles(\"left\");\n    } else if (e.keyCode === 39) { // right\n      game.moveTiles(\"right\");\n    }\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","const DIRECTIONAL_CONSTANTS = {\n  up: [-1, 0],\n  down: [1, 0],\n  left: [0, -1],\n  right: [0, 1]\n}\n\nfunction Game(){\n  this.generateBoard();\n  this.score = 0;\n}\n\nGame.prototype.generateBoard = function(){\n  this.transitions = new Array(4);\n  this.board = new Array(4);\n  for (let i = 0; i < this.board.length; i++) {\n    this.transitions[i] = [null, null, null, null];\n    this.board[i] = [null, null, null, null];\n  }\n  this.generateRandomTile(2);\n  this.render();\n}\n\nGame.prototype.checkForOpenSpaces = function () {\n  let response = false;\n  this.board.forEach(function(row){\n    if (row.some(function(pos){return pos == null})){\n      response = true;\n    }\n  });\n  return response;\n};\n\nGame.prototype.over = function(){\n  let bool = true;\n  for (let x = 0; x < this.board.length; x++) {\n    for (let y = 0; y < this.board[x].length; y++) {\n      for (let dir in DIRECTIONAL_CONSTANTS) {\n        let diffX = DIRECTIONAL_CONSTANTS[dir][0];\n        let diffY = DIRECTIONAL_CONSTANTS[dir][1];\n        if (inBounds([x + diffX, y + diffY])) {\n          if (this.board[x][y] === this.board[x + diffX][y + diffY]) {\n            bool = false;\n          } else if (this.checkForOpenSpaces()) {\n            bool = false;\n          }\n        }\n      }\n    }\n  }\n  return bool;\n}\n\nGame.prototype.generateRandomTile = function(num) {\n  if (!this.checkForOpenSpaces()) {\n    return;\n  }\n  for (let i = 0; i < num; i++) {\n    let x = Math.round(Math.random() * 3)\n    let y = Math.round(Math.random() * 3)\n    while (this.board[x][y] !== null) {\n      x = Math.round(Math.random() * 3)\n      y = Math.round(Math.random() * 3)\n    }\n    this.board[x][y] = [2,4][Math.round(Math.random())];\n    this.transitions[x][y] = \"new-tile\"\n  }\n};\n\nGame.prototype.render = function () {\n  let lastScore = $(\"#gamescore\").text();\n  let scoreDiff = this.score - parseInt(lastScore);\n  $(\"#gamescore\").text(this.score);\n  if (scoreDiff > 0) {\n    $(\"#scorediff\").text(`+${scoreDiff}`);\n  }\n  for (let x = 0; x < this.board.length; x++) {\n    for (let y = 0; y < this.board.length; y++) {\n      let color = colorFinder(this.board[x][y]);\n      let square = $(document).find(`[data-pos=\"${[x,y]}\"]`)\n      square.removeClass();\n      if (this.board[x][y] !== null) {\n        square.css(\"background\", color);\n        square.text(this.board[x][y])\n        square.addClass(this.transitions[x][y]);\n      } else {\n        square.css(\"background\", \"#6492ac\");\n        square.text(\"\")\n      }\n    }\n  }\n};\n\nGame.prototype.resetTransitions = function () {\n  this.transitions = new Array(4);\n  for (let i = 0; i < this.board.length; i++) {\n    this.transitions[i] = [null, null, null, null];\n  }\n};\n\nGame.prototype.moveTiles = function(direction){\n  this.resetTransitions();\n  if ([\"up\", \"left\"].includes(direction)){\n    for (let x = 0; x < this.board.length; x++) {\n      for (let y = 0; y < this.board[x].length; y++) {\n        if (this.board[x][y] !== null) {\n          this.moveTile([x, y], this.board[x][y], direction);\n        }\n      }\n    }\n  } else {\n    for (let x = this.board.length - 1; x >= 0; x--) {\n      for (let y = this.board.length - 1; y >= 0; y--) {\n        if (this.board[x][y] !== null) {\n          this.moveTile([x, y], this.board[x][y], direction);\n        }\n      }\n    }\n  }\n  this.generateRandomTile(1);\n  this.render();\n  if (this.over()) {\n    $(\"#gameboard\").addClass(\"gameover\");\n    $(\"#gameover-modal\").show();\n  }\n}\n\n$(\"#play-again\").click(function(e){\n  $(\"#gameboard\").removeClass(\"game-over\");\n  let game = new Game();\n  game.render();\n});\n\n\nGame.prototype.moveTile = function(currentPos, currentValue, direction){\n  let currentX = currentPos[0];\n  let currentY = currentPos[1];\n  let dir = DIRECTIONAL_CONSTANTS[direction];\n  // console.log(currentValue);\n  while (true) { //while next move is still on the board;\n    if (nextMoveInBounds([currentX, currentY], direction)){\n      // console.log(\"next move is in bounds\");\n      if (this.nextMoveHitsAnotherTile([currentX, currentY], direction)){\n        // console.log(\"next move hits another tile\");\n        let nextX = currentX + dir[0];\n        let nextY = currentY + dir[1];\n        if (this.board[nextX][nextY] === currentValue) {\n          // console.log(\"next move hits another LIKE current tile\");\n          this.board[nextX][nextY] *= 2;\n          this.board[currentPos[0]][currentPos[1]] = null;\n          this.score += this.board[nextX][nextY]\n          this.transitions[nextX][nextY] = \"double\";\n          if ([\"up\", \"down\"].includes(direction)) {\n            this.transitions[currentPos[0]][currentPos[1]] = `${direction}-${Math.abs(nextY - currentPos[1])}`;\n          } else {\n            this.transitions[currentPos[0]][currentPos[1]] = `${direction}-${Math.abs(nextX - currentPos[0])}`;\n          }\n          break;\n        } else {\n          // console.log(\"next move hits another tile that is UNLIKE current tile\");\n          this.board[currentPos[0]][currentPos[1]] = null;\n          this.board[currentX][currentY] = currentValue;\n          if ([\"up\", \"down\"].includes(direction)) {\n            this.transitions[currentX][currentY] = `${direction}-${Math.abs(currentPos[0] - currentX)}`;\n          } else {\n            this.transitions[currentX][currentY] = `${direction}-${Math.abs(currentPos[1] - currentY)}`;\n          }\n          break;\n        }\n      } else {\n        // console.log(\"next move does not hit another tile\");\n        currentX += dir[0];\n        currentY += dir[1];\n      }\n    } else {\n      // console.log(\"next move is OUT of bounds\");\n      this.board[currentPos[0]][currentPos[1]] = null;\n      this.board[currentX][currentY] = currentValue;\n      if ([\"up\", \"down\"].includes(direction)) {\n        this.transitions[currentX][currentY] = `${direction}-${Math.abs(currentPos[0] - currentX)}`;\n      } else {\n        this.transitions[currentX][currentY] = `${direction}-${Math.abs(currentPos[1] - currentY)}`;\n      }\n      break;\n    }\n  }\n  this.render();\n  return;\n}\n\nfunction inBounds(pos) {\n  return (pos[0] >= 0 && pos[0] <= 3 && pos[1] >= 0 && pos[1] <= 3);\n}\n\nfunction nextMoveInBounds(currentPos, direction){\n  let dir = DIRECTIONAL_CONSTANTS[direction];\n  return (inBounds([currentPos[0] + dir[0], currentPos[1] + dir[1]]));\n}\n\nGame.prototype.nextMoveHitsAnotherTile = function(pos, direction){\n  dir = DIRECTIONAL_CONSTANTS[direction];\n  nextX = pos[0] + dir[0];\n  nextY = pos[1] + dir[1]\n  return (this.board[nextX][nextY] !== null);\n}\n\nfunction colorFinder(value){\n  switch (value){\n    case 2:\n      return \"orangered\";\n    case 4:\n      return \"crimson\";\n    case 8:\n      return \"orange\";\n    case 16:\n      return \"gold\";\n    case 32:\n      return \"yellow\";\n    case 64:\n      return \"yellowgreen\";\n    case 128:\n      return \"chartreuse\";\n    case 256:\n      return \"limegreen\";\n    case 512:\n      return \"lightseagreen\";\n    case 1024:\n      return \"cornflowerblue\";\n    case 2048:\n      return \"royalblue\";\n    case 4096:\n      return \"purple\";\n    case 8192:\n      return \"plum\";\n  }\n}\n\nmodule.exports = Game;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/game.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}